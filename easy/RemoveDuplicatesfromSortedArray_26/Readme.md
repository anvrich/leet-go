# №26 Remove Duplicates from Sorted Array

## 1. Описание задачи

Дан целочисленный массив `nums`, отсортированный в неубывающем порядке. Необходимо "на месте" удалить дубликаты, чтобы каждый уникальный элемент появлялся только один раз. Порядок элементов должен быть сохранен. Верните количество уникальных элементов в массиве.

**Важно**: Массив `nums` изменяется таким образом, что первые `k` элементов содержат уникальные значения в исходном порядке. Остальная часть массива не важна.

### Примеры:

**Пример 1:**

- Ввод: `nums = [1,1,2]`
- Вывод: `2, nums = [1,2,_]`
- Пояснение: Функция должна вернуть `k = 2`, и первые два элемента `nums` будут `[1, 2]`. Неважно, что стоит за `k`, поэтому здесь `_` может быть любым значением.

**Пример 2:**

- Ввод: `nums = [0,0,1,1,1,2,2,3,3,4]`
- Вывод: `5, nums = [0,1,2,3,4,_,_,_,_,_]`
- Пояснение: Функция должна вернуть `k = 5`, и первые пять элементов `nums` будут `[0, 1, 2, 3, 4]`.

## 2. Ограничения

- `1 <= nums.length <= 3 * 10^4`
- `-100 <= nums[i] <= 100`
- Массив `nums` отсортирован в неубывающем порядке.

## 3. Подход к решению

### Разбор задачи:
- Поскольку массив отсортирован, все дубликаты будут расположены подряд.
- Нужно пройти по массиву, сравнивая текущий элемент с предыдущим уникальным элементом. Если текущий элемент не равен предыдущему уникальному, то это новый уникальный элемент, который нужно сохранить.

### Алгоритм:
1. Если длина массива равна 0, возвращаем `0` (нет элементов для обработки).
2. Инициализируем переменную `uniqueCount` со значением `1`, так как первый элемент всегда уникален.
3. Проходим по массиву, начиная со второго элемента:
    - Если текущий элемент отличается от предыдущего уникального элемента, добавляем его в `nums` на позицию `uniqueCount` и увеличиваем `uniqueCount`.
4. В конце `uniqueCount` будет содержать количество уникальных элементов в массиве.

### [Код:](./RemoveDuplicates.go)
```go
func RemoveDuplicates(nums []int) int {
    if len(nums) == 0 {
        return 0
    }

    uniqueCount := 1
    for i := 1; i < len(nums); i++ {
        if nums[i] != nums[i-1] {
            nums[uniqueCount] = nums[i]
            uniqueCount++
        }
    }

    return uniqueCount
}
```

## 4. Алгоритм и сложность

### Время выполнения:
- **O(n)**, где `n` — количество элементов в массиве, так как мы проходим по массиву только один раз.

### Использование памяти:
- **O(1)**, так как мы не используем дополнительных структур данных, а изменяем массив "на месте".

## 5. Пример использования

### Ввод:
```text
nums = [0,0,1,1,1,2,2,3,3,4]
```

### Вывод:
```text
5, nums = [0,1,2,3,4,_,_,_,_,_]
```

