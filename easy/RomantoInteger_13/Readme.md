

# Roman to Integer

## 1. Описание задачи

Римские цифры представлены семью различными символами: `I`, `V`, `X`, `L`, `C`, `D` и `M`.

| Символ | Значение |
|--------|----------|
| I      | 1        |
| V      | 5        |
| X      | 10       |
| L      | 50       |
| C      | 100      |
| D      | 500      |
| M      | 1000     |

Например, число 2 записывается как `II`, 12 — это `XII`, а 27 — это `XXVII`.

Римские цифры обычно записываются от большего к меньшему слева направо. Однако для чисел 4 и 9 используется вычитание: 4 записывается как `IV`, а 9 — как `IX`. Это правило распространяется на следующие комбинации:

- `I` можно ставить перед `V` (5) и `X` (10), чтобы получить 4 и 9.
- `X` можно ставить перед `L` (50) и `C` (100), чтобы получить 40 и 90.
- `C` можно ставить перед `D` (500) и `M` (1000), чтобы получить 400 и 900.

Задача: преобразовать римское число в целое.

### Примеры:

**Пример 1:**

- Ввод: `s = "III"`
- Вывод: `3`
- Пояснение: `III = 3`

**Пример 2:**

- Ввод: `s = "LVIII"`
- Вывод: `58`
- Пояснение: `L = 50`, `V = 5`, `III = 3`

**Пример 3:**

- Ввод: `s = "MCMXCIV"`
- Вывод: `1994`
- Пояснение: `M = 1000`, `CM = 900`, `XC = 90`, `IV = 4`

## 2. Ограничения

- 1 <= длина строки `s` <= 15
- Строка содержит только символы ('I', 'V', 'X', 'L', 'C', 'D', 'M').
- Гарантируется, что строка является допустимым римским числом в диапазоне [1, 3999].

## 3. Подход к решению

### Алгоритм:
1. Создаем карту (словарь) для сопоставления римских символов с их числовыми значениями.
2. Проходим по строке справа налево, добавляя значение символа к результату.
3. Если значение текущего символа меньше предыдущего (например, `I` перед `V` или `X`), вычитаем его из результата.

### [Код:](./RomanToInt.go)
```go
func romanToInt(s string) int {
    romanMap := map[byte]int{
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000,
    }
    
    total := 0
    prevValue := 0

    for i := len(s) - 1; i >= 0; i-- {
        currentValue := romanMap[s[i]]
        if currentValue < prevValue {
            total -= currentValue
        } else {
            total += currentValue
        }
        prevValue = currentValue
    }

    return total
}
```

## 4. Алгоритм и сложность

### Время выполнения:
- **O(n)**, где `n` — длина строки.

### Использование памяти:
- **O(1)**, так как используем фиксированное количество памяти для хранения карты и переменных.

## 5. Пример использования

### Ввод:
```go
s = "MCMXCIV"
```

### Вывод:
```go
1994
```